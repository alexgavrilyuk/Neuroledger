const logger = require('../../../shared/utils/logger');

/**
 * @typedef {object} FinalAnswerResult
 * @property {boolean} isFinalAnswer - Always true, signals the orchestrator.
 */

/**
 * Tool implementation used by the LLM to signal that it has formulated the final textual answer.
 * This tool doesn't perform any action itself but serves as a marker for the AgentExecutor
 * to stop the reasoning loop and use the LLM's provided text as the final response.
 *
 * The actual `textResponse` argument provided by the LLM is primarily for logging and confirmation;
 * the AgentExecutor typically uses the full text generated by the LLM in the turn where this tool is called.
 *
 * @async
 * @param {object} args - Tool arguments provided by the LLM.
 * @param {string} args.textResponse - The final textual response intended for the user (as formulated by the LLM).
 * @param {object} context - Additional context provided by the orchestrator.
 * @param {string} context.userId - The ID of the user making the request.
 * @param {string} context.sessionId - The ID of the current chat session.
 * @returns {Promise<{status: 'success', result: FinalAnswerResult}>} A success status object explicitly indicating this is the final answer signal.
 */
async function answer_user(args, context) {
    const { textResponse } = args;
    const { userId, sessionId } = context;

    // Log that the agent decided to answer.
    logger.info(`[Tool:_answerUserTool] Called by User ${userId} in Session ${sessionId}. Final answer provided by LLM.`);

    if (typeof textResponse !== 'string' || textResponse.trim() === '') {
         logger.warn(`[Tool:_answerUserTool] Invoked with empty or invalid textResponse argument by LLM.`);
         // Still signal success, as the intent is to answer. The orchestrator should have the raw response.
         return { status: 'success', result: { isFinalAnswer: true } };
    }

    // This tool doesn't need to *do* anything with the textResponse itself,
    // the orchestrator uses the LLM's invocation of this tool as the signal to stop.
    // We just return a success status to confirm the tool was correctly called.
    return {
        status: 'success',
        result: { isFinalAnswer: true } // Explicitly signal this is the final answer
    };
}

module.exports = answer_user; 